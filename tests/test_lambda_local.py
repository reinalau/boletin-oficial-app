#!/usr/bin/env python3
"""
Script para probar la lambda_function localmente
Simula el entorno de AWS Lambda y API Gateway
"""

import os
import sys
import json
from datetime import datetime
from dotenv import load_dotenv

# Agregar directorio padre al path para importar lambda_function
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Cargar variables de entorno
load_dotenv()

# Simular contexto de Lambda
class MockLambdaContext:
    """Mock del contexto de AWS Lambda"""
    
    def __init__(self):
        self.function_name = "boletin-oficial-analyzer-local"
        self.function_version = "$LATEST"
        self.invoked_function_arn = "arn:aws:lambda:us-east-1:123456789012:function:boletin-oficial-analyzer-local"
        self.memory_limit_in_mb = "1024"
        self.remaining_time_in_millis = 300000  # 5 minutos
        self.log_group_name = "/aws/lambda/boletin-oficial-analyzer-local"
        self.log_stream_name = "2025/08/04/[$LATEST]abcdef123456"
        self.aws_request_id = "12345678-1234-1234-1234-123456789012"
    
    def get_remaining_time_in_millis(self):
        """Simula tiempo restante de ejecuci√≥n"""
        return self.remaining_time_in_millis

def create_api_gateway_event(fecha=None, forzar_reanalisis=False):
    """
    Crea un evento simulado de API Gateway
    
    Args:
        fecha: Fecha para an√°lisis (YYYY-MM-DD)
        forzar_reanalisis: Si forzar nuevo an√°lisis
        
    Returns:
        dict: Evento simulado de API Gateway
    """
    if not fecha:
        fecha = datetime.now().strftime('%Y-%m-%d')
    
    body_data = {
        "fecha": fecha,
        "forzar_reanalisis": forzar_reanalisis
    }
    
    event = {
        "resource": "/analyze",
        "path": "/analyze",
        "httpMethod": "POST",
        "headers": {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Host": "localhost:3000",
            "User-Agent": "LocalTest/1.0"
        },
        "multiValueHeaders": {},
        "queryStringParameters": None,
        "multiValueQueryStringParameters": None,
        "pathParameters": None,
        "stageVariables": None,
        "requestContext": {
            "resourceId": "abc123",
            "resourcePath": "/analyze",
            "httpMethod": "POST",
            "extendedRequestId": "local-test-123",
            "requestTime": datetime.now().strftime('%d/%b/%Y:%H:%M:%S %z'),
            "path": "/v1/analyze",
            "accountId": "123456789012",
            "protocol": "HTTP/1.1",
            "stage": "v1",
            "domainPrefix": "localhost",
            "requestTimeEpoch": int(datetime.now().timestamp() * 1000),
            "requestId": "local-test-request-123",
            "identity": {
                "cognitoIdentityPoolId": None,
                "accountId": None,
                "cognitoIdentityId": None,
                "caller": None,
                "sourceIp": "127.0.0.1",
                "principalOrgId": None,
                "accessKey": None,
                "cognitoAuthenticationType": None,
                "cognitoAuthenticationProvider": None,
                "userArn": None,
                "userAgent": "LocalTest/1.0",
                "user": None
            },
            "domainName": "localhost",
            "apiId": "local-test"
        },
        "body": json.dumps(body_data),
        "isBase64Encoded": False
    }
    
    return event

def test_lambda_function_local():
    """Prueba la funci√≥n Lambda localmente"""
    
    print("üß™ Test Local de Lambda Function")
    print("=" * 50)
    
    # Usar fecha espec√≠fica para testing consistente
    test_date = datetime.now().strftime('%Y-%m-%d')  # Fecha actual
    print(f"üìÖ Fecha de prueba: {test_date}")
    print("üîÑ Flujo de prueba:")
    print("   1. Primera llamada: Busca en BD ‚Üí No existe ‚Üí Llama Gemini ‚Üí Guarda en BD")
    print("   2. Segunda llamada: Busca en BD ‚Üí Existe ‚Üí Retorna desde cache")
    print("   3. Tercera llamada (forzada): Ignora cache ‚Üí Llama Gemini ‚Üí Actualiza BD")
    
    # Verificar variables de entorno
    print("\n1Ô∏è‚É£ Verificando configuraci√≥n...")
    required_vars = ['GEMINI_API_KEY', 'MONGODB_CONNECTION_STRING', 'MONGODB_DATABASE', 'MONGODB_COLLECTION']
    
    missing_vars = []
    for var in required_vars:
        if not os.getenv(var):
            missing_vars.append(var)
    
    if missing_vars:
        print("‚ùå Variables de entorno faltantes:")
        for var in missing_vars:
            print(f"   - {var}")
        return False
    
    print("‚úÖ Variables de entorno configuradas")
    print(f"   - Modelo LLM: {os.getenv('LANGCHAIN_MODEL', 'gemini-2.5-flash')}")
    print(f"   - Temperatura: {os.getenv('LANGCHAIN_TEMPERATURE', '1')}")
    
    # Importar la funci√≥n Lambda
    print("\n2Ô∏è‚É£ Importando lambda_function...")
    try:
        from lambda_function import lambda_handler
        print("‚úÖ lambda_function importada correctamente")
    except ImportError as e:
        print(f"‚ùå Error importando lambda_function: {e}")
        return False
    
    # Crear contexto mock
    context = MockLambdaContext()
    
    # Test 1: Primera llamada - Deber√≠a ir a Gemini (no existe en BD)
    print(f"\n3Ô∏è‚É£ Test 1: Primera llamada - An√°lisis nuevo ({test_date})")
    print("-" * 50)
    print("üîç Flujo esperado: BD (no existe) ‚Üí Gemini ‚Üí Guardar en BD")
    
    event1 = create_api_gateway_event(fecha=test_date)
    print(f"üìÖ Fecha solicitada: {json.loads(event1['body'])['fecha']}")
    
    try:
        print("üöÄ Ejecutando lambda_handler...")
        start_time = datetime.now()
        
        response1 = lambda_handler(event1, context)
        
        end_time = datetime.now()
        execution_time = (end_time - start_time).total_seconds()
        
        print(f"‚è±Ô∏è  Tiempo de ejecuci√≥n: {execution_time:.2f} segundos")
        print(f"üìä Status Code: {response1['statusCode']}")
        
        if response1['statusCode'] == 200:
            print("‚úÖ Test 1 exitoso")
            
            # Parsear respuesta
            body = json.loads(response1['body'])
            if body['success']:
                data = body['data']
                print(f"ÔøΩ Resuimen: {data['analisis']['resumen'][:100]}...")
                print(f"üìä Cambios principales: {len(data['analisis']['cambios_principales'])} identificados")
                print(f"üéØ √Åreas afectadas: {', '.join(data['analisis']['areas_afectadas'])}")
                print(f"üë• Opiniones de expertos: {len(data['opiniones_expertos'])}")
                from_cache = data['metadatos'].get('desde_cache', False)
                print(f"‚ö° Desde cache: {from_cache}")
                
                if not from_cache:
                    print("‚úÖ Correcto: Primera llamada proces√≥ con Gemini")
                else:
                    print("‚ö†Ô∏è  Inesperado: Primera llamada us√≥ cache")
            else:
                print(f"‚ùå Error en respuesta: {body.get('message', 'Error desconocido')}")
                return False
        else:
            print(f"‚ùå Test 1 fall√≥ con status {response1['statusCode']}")
            body = json.loads(response1['body'])
            print(f"   Error: {body.get('message', 'Error desconocido')}")
            return False
            
    except Exception as e:
        print(f"‚ùå Error ejecutando Test 1: {e}")
        import traceback
        print(traceback.format_exc())
        return False
    
    # Test 2: Segunda llamada - Deber√≠a usar cache (existe en BD)
    print("\n4Ô∏è‚É£ Test 2: Segunda llamada - Desde cache")
    print("-" * 40)
    print("üîç Flujo esperado: BD (existe) ‚Üí Retornar desde cache")
    
    event2 = create_api_gateway_event(fecha=test_date)
    
    try:
        print("üöÄ Ejecutando lambda_handler (segunda vez)...")
        start_time = datetime.now()
        
        response2 = lambda_handler(event2, context)
        
        end_time = datetime.now()
        execution_time = (end_time - start_time).total_seconds()
        
        print(f"‚è±Ô∏è  Tiempo de ejecuci√≥n: {execution_time:.2f} segundos (deber√≠a ser < 5 seg)")
        print(f"üìä Status Code: {response2['statusCode']}")
        
        if response2['statusCode'] == 200:
            body = json.loads(response2['body'])
            if body['success']:
                data = body['data']
                from_cache = data['metadatos'].get('desde_cache', False)
                print(f"‚ö° Desde cache: {from_cache}")
                
                if from_cache and execution_time < 5:
                    print("‚úÖ Test 2 exitoso - Cache funcionando correctamente")
                elif from_cache:
                    print("‚ö†Ô∏è  Test 2 - Cache funcion√≥ pero tard√≥ m√°s de lo esperado")
                else:
                    print("‚ùå Test 2 - No us√≥ cache cuando deber√≠a haberlo hecho")
                    return False
            else:
                print(f"‚ùå Error en respuesta: {body.get('message', 'Error desconocido')}")
                return False
        else:
            print(f"‚ùå Test 2 fall√≥ con status {response2['statusCode']}")
            return False
            
    except Exception as e:
        print(f"‚ùå Error ejecutando Test 2: {e}")
        print("‚ÑπÔ∏è  Continuando con otros tests...")
        return False
    
    # Test 3: Tercera llamada - An√°lisis forzado (ignora cache)
    print("\n5Ô∏è‚É£ Test 3: Tercera llamada - An√°lisis forzado")
    print("-" * 40)
    print("üîç Flujo esperado: Ignorar BD ‚Üí Gemini ‚Üí Actualizar BD")
    
    event3 = create_api_gateway_event(
        fecha=test_date, 
        forzar_reanalisis=True
    )
    
    try:
        print("üöÄ Ejecutando lambda_handler (forzado)...")
        start_time = datetime.now()
        
        response3 = lambda_handler(event3, context)
        
        end_time = datetime.now()
        execution_time = (end_time - start_time).total_seconds()
        
        print(f"‚è±Ô∏è  Tiempo de ejecuci√≥n: {execution_time:.2f} segundos (deber√≠a ser > 10 seg)")
        print(f"üìä Status Code: {response3['statusCode']}")
        
        if response3['statusCode'] == 200:
            body = json.loads(response3['body'])
            if body['success']:
                data = body['data']
                from_cache = data['metadatos'].get('desde_cache', False)
                print(f"‚ö° Desde cache: {from_cache} (deber√≠a ser False)")
                
                if not from_cache and execution_time > 10:
                    print("‚úÖ Test 3 exitoso - An√°lisis forzado funcionando correctamente")
                elif not from_cache:
                    print("‚ö†Ô∏è  Test 3 - An√°lisis forzado funcion√≥ pero fue muy r√°pido")
                else:
                    print("‚ùå Test 3 - Us√≥ cache cuando deber√≠a haber forzado nuevo an√°lisis")
                    return False
            else:
                print(f"‚ùå Error en respuesta: {body.get('message', 'Error desconocido')}")
                return False
        else:
            print(f"‚ùå Test 3 fall√≥ con status {response3['statusCode']}")
            return False
            
    except Exception as e:
        print(f"‚ùå Error ejecutando Test 3: {e}")
        print("‚ÑπÔ∏è  Continuando...")
        return False
    
    # Test 4: Fecha diferente - Deber√≠a ir a Gemini (nueva fecha)
    print("\n6Ô∏è‚É£ Test 4: Fecha diferente - An√°lisis nuevo")
    print("-" * 40)
    
    # Usar fecha de ayer para probar con fecha diferente
    from datetime import timedelta
    yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
    print(f"üîç Flujo esperado: BD (fecha {yesterday} no existe) ‚Üí Gemini ‚Üí Guardar en BD")
    
    event4 = create_api_gateway_event(fecha=yesterday)
    
    try:
        print(f"üöÄ Ejecutando lambda_handler con fecha {yesterday}...")
        start_time = datetime.now()
        
        response4 = lambda_handler(event4, context)
        
        end_time = datetime.now()
        execution_time = (end_time - start_time).total_seconds()
        
        print(f"‚è±Ô∏è  Tiempo de ejecuci√≥n: {execution_time:.2f} segundos")
        print(f"üìä Status Code: {response4['statusCode']}")
        
        if response4['statusCode'] == 200:
            body = json.loads(response4['body'])
            if body['success']:
                data = body['data']
                from_cache = data['metadatos'].get('desde_cache', False)
                print(f"‚ö° Desde cache: {from_cache} (deber√≠a ser False)")
                print(f"üìÖ Fecha procesada: {data['fecha']}")
                
                if not from_cache and data['fecha'] == yesterday:
                    print("‚úÖ Test 4 exitoso - Fecha diferente procesada correctamente")
                else:
                    print("‚ö†Ô∏è  Test 4 - Comportamiento inesperado con fecha diferente")
            else:
                print(f"‚ùå Error en respuesta: {body.get('message', 'Error desconocido')}")
        else:
            print(f"‚ùå Test 4 fall√≥ con status {response4['statusCode']}")
            
    except Exception as e:
        print(f"‚ùå Error ejecutando Test 4: {e}")
        print("‚ÑπÔ∏è  Continuando...")

    print("\nüéâ Tests locales completados!")
    print("\nüìä Resumen del flujo probado:")
    print("   ‚úÖ Primera llamada: BD ‚Üí Gemini ‚Üí Guardar")
    print("   ‚úÖ Segunda llamada: BD ‚Üí Cache")
    print("   ‚úÖ Tercera llamada (forzada): Gemini ‚Üí Actualizar BD")
    print("   ‚úÖ Cuarta llamada (fecha diferente): BD ‚Üí Gemini ‚Üí Guardar")
    
    return True

def show_usage():
    """Muestra informaci√≥n de uso"""
    print("\nüìã Uso del script:")
    print("=" * 30)
    print("python test_lambda_local.py")
    print()
    print("üìã Variables de entorno requeridas:")
    print("   - GEMINI_API_KEY")
    print("   - MONGODB_CONNECTION_STRING")
    print("   - MONGODB_DATABASE")
    print("   - MONGODB_COLLECTION")
    print()
    print("üìã Variables opcionales:")
    print("   - LANGCHAIN_MODEL (default: gemini-2.5-flash)")
    print("   - LANGCHAIN_TEMPERATURE (default: 0.1)")

if __name__ == "__main__":
    print("üß™ Test Local de AWS Lambda Function")
    print("=" * 50)
    print("Este script simula el entorno de AWS Lambda localmente")
    print("para probar toda la funcionalidad sin desplegar.")
    print()
    print("‚ÑπÔ∏è  Probando flujo completo de Lambda:")
    print("   üì• Lambda recibe fecha ‚Üí üîç Busca en MongoDB ‚Üí ü§ñ Llama Gemini si no existe ‚Üí üíæ Guarda resultado")
    print("   ‚ö° Sin LangChain - Usa google-genai directamente")
    print("   üß† Thinking habilitado - An√°lisis m√°s profundo")
    print("   üîç Google Search - Acceso directo a URLs del Bolet√≠n Oficial")
    
    success = test_lambda_function_local()
    
    if success:
        print("\n‚úÖ RESULTADO: Funcionalidad local funcionando correctamente")
        print("   Tu aplicaci√≥n est√° lista para desplegar a AWS Lambda")
    else:
        print("\n‚ùå RESULTADO: Hay problemas en la funcionalidad")
        print("   Revisa los errores anteriores antes de desplegar")
        print("\nüí° Posibles causas:")
        print("   - Fecha sin contenido en Bolet√≠n Oficial")
        print("   - Problemas de conectividad")
        print("   - API de Gemini sin cuota")
        print("   - MongoDB no accesible")
    
    show_usage()
    
    sys.exit(0 if success else 1)